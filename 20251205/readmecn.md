# 1 确认触发warning的地方

通过查看report和内核源码，可以定位触发warning的位置在 fs/udf/inode.c：2083，即：

```c
int __udf_add_aext(struct inode *inode, struct extent_position *epos,
		   struct kernel_lb_addr *eloc, uint32_t elen, int inc)
{
	...
	if (!epos->bh) {
		WARN_ON(iinfo->i_lenAlloc !=
			epos->offset - udf_file_entry_alloc_offset(inode));
	} 
	...
}
```

这个WARN_ON应该是在检查UDF文件的extent描述区是否被损坏或篡改。

# 2 理解复现程序

```syz
syz_mount_image$udf(&(0x7f0000001040), &(0x7f0000001080)='./file0\x00', 0x0, &(0x7f0000000100)={[{@iocharset={'iocharset', 0x3d, 'macinuit'}}, {@shortad}]}, 0x1, 0x1030, &(0x7f0000001100)="A large number of strings randomly generated by the fuzzer")
r0 = openat$snapshot(0xffffffffffffff9c, &(0x7f0000000000), 0x200001, 0x0)
r1 = creat(&(0x7f0000000380)='./file1\x00', 0x104)
write$binfmt_elf64(r1, 0x0, 0x768)
close_range(r0, 0xffffffffffffffff, 0x0)
r2 = creat(0x0, 0x104)
truncate(&(0x7f0000000240)='./file1\x00', 0xeba)
ioctl$FIBMAP(r2, 0x1, 0x0)
```

这个bug的出现主要和mount和truncate有关：

* udf的mount在处理用户传入的data时，没有做充分的/严格的检查。这会出现一种情况，当传入的data是随机数据/垃圾数据时，内核并不会检查/检查没有那么严格，从而导致mount的过程虽然正确执行，而实际上内核的udf数据结构已经被破坏了。
* truncate试图让内核为UDF分配新extent时，会做检查，也就是第一节分析的那样，但这只是一个warning。如果内核继续运行(在我们的场景下，warning会导致内核panic)，或许会出现严重的内存方面bug，因为此时udf数据结构被破坏了。
